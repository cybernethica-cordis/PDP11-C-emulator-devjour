## Сверхкраткое введение

Дана *гипотетическая вычислительная машина «Q»* с четырьмя **регистрами** (ячейками памяти), размером **1 байт** каждый. У каждого регистра есть **имя** и **адрес**, по которому к нему можно обратиться.

| Имя | Адрес |
| --- | ----- |
| A   | 5     |
| B   | 6     |
| C   | 7     |
| D   | 8     |

При написании текста программы программист использует **мнемоники** — символьные обозначения машинных **операций**, они же *инструкции* (команды для выполнения машиной). Программист видит программу как последовательность мнемоник с **операндами**. Для машины инструкции представлены в виде **кодов операций** (*opcodes*) — числовых значений.

| Код операции | Мнемоника | Операнды   | Операция  (инструкция)                                                                                                         |
| ------------ | --------- | ---------- | ------------------------------------------------------------------------------------------------------------------------------ |
| 0            | HLT       | —          | Завершить программу                                                                                                            |
| 1            | ADD       | reg1 reg2  | Сложить значения, хранящиеся в регистрах *reg1* и *reg2*, результат сложения записать в *reg1* (*reg2* оставить без изменения) |
| 2            | SUB       | reg1 reg2  | Вычесть значение *reg2* из значения *reg1*, результат вычитания записать в *reg1* (*reg2* оставить без изменения)              |
| 3            | MOV       | reg number | Записать указанное значение (*number*) в регистр (*reg*)                                                                       |
| 4            | IR        | —          | Вывести на экран значения всех регистров в порядке A, B, C, D                                                                  |

Дана программа в виде последовательности числовых кодов операций для выполнения машиной. Будем называть такую программу **байт-кодом**, так как в архитектуре гипотетической вычислительной машины «Q» каждый *опкод* занимает 1 байт.

```C
3 5 1
3 6 2
1 5 6
4
0
```

В выводе получаем:

```C
3 2 0 0
```

Почему `3200`?

## **Чтение**

Читаем и интерпретируем байт-код последовательно, строка за строкой. Первая инструкция представлена последовательностью чисел `3`, `5` и `1`, что значит: «Код `3` означает операцию `MOV`, то есть запись значения в регистр»; «число `5` означает первый операнд операции `MOV`, а именно адрес номер `5`, который носит имя регистра `A`»; «число `1` означает второй операнд операции `MOV`, а именно целое число `1`, которое следует записать в регистр `A`». Первое число строки означает операцию, а два следующих обозначают ее операнды. Операция `MOV` принимает два операнда — адрес регистра и число, которое в него записывается.

Читаем дальше:

| Байт-код | Мнемоника | Операция (инструкция)                                                                            | Содержимое регистров A B C D после выполнения операции |
| -------- | --------- | ------------------------------------------------------------------------------------------------ | ------------------------------------------------------ |
| 3 5 1    | MOV A 1   | Записать в регистр А число 1                                                                     | 1 0 0 0                                                |
| 3 6 2    | MOV B 2   | Записать в регистр B число 2                                                                     | 1 2 0 0                                                |
| 1 5 6    | ADD A B   | Сложить значения, хранящиеся в регистрах A и B, результат записать в A, оставить без изменений B | 3 2 0 0                                                |
| 4        | IR        | Вывести на печать содержимое всех регистров                                                      | 3 2 0 0                                                |
| 0        | HLT       | Завершить программу                                                                              | 3 2 0 0                                                |

Рассмотрим **еще один пример**. Дана программа в виде байт-кода:

```C
3 6 7
3 7 1
2 6 7
4
0
```

В выводе получаем:

```C
0 6 1 0
```

Читаем программу:

| Байт-код | Мнемоника | Операция (инструкция)                                                                                  | Содержимое регистров A B C D после выполнения операции |
| -------- | --------- | ------------------------------------------------------------------------------------------------------ | ------------------------------------------------------ |
| 3 6 7    | MOV B 7   | Записать в регистр B число 7                                                                           | 0 7 0 0                                                |
| 3 7 1    | MOV C 1   | Записать в регистр C число 1                                                                           | 0 7 1 0                                                |
| 2 6 7    | SUB B C   | Вычесть из значения регистра B — значение регистра С, результат записать в B, оставить без изменений C | 0 6 1 0                                                |
| 4        | IR        | Вывести на печать содержимое всех регистров                                                            | 0 6 1 0                                                |
| 0        | HLT       | Завершить программу                                                                                    | 0 6 1 0                                                |

## **Письмо**

Теперь *напишем программу на языке C* такую, что роль регистров вычислительной машины «Q» в ней будут выполнять **переменные**. Будем читать байт-код, интерпретировать коды операций, изменять значения переменных («регистров») согласно байт-коду и выводить результат (содержимое переменных, или «регистров»). Иными словами, реализуем интерпретатор, который выполняет байт-код, обновляя значения регистров и выводя результат.

Байт-код программы:

```C
3 5 1  
3 6 2  
1 5 6  
4  
0
```

После выполнения операций `MOV` и `ADD` получаем:

```C
3 2 0 0
```

Первые два регистра (`A` и `B`) содержат значения `3` и `2`, остальные регистры (`C` и `D`) содержат нулевые значения.

Сперва приведем *несколько работающих решений*, затем разберем и прокомментируем каждое, чтобы показать *лучшее*. **Данные для тестирования** программы см. в папке: `test/1.2.test.md`.

### **Решение с использованием `if...else`**

```C
#include <stdio.h>
#include <stdint.h>

int main() {
    /* Инициализация памяти: 256 ячеек по 8 бит. Регистры A, B, C, D — по адресам 5–8 */
    uint8_t reg[256] = {0};
    int opcode;

    /* Основной цикл: считываем и интерпретируем инструкции */
    while (scanf("%d", &opcode) == 1) {
        if (opcode == 0) {
            // HLT: Остановить выполнение
            break;
        } else if (opcode == 1) {
            // ADD r1 r2: A[r1] = (A[r1] + A[r2]) % 256
            int r1, r2;
            scanf("%d %d", &r1, &r2);
            reg[r1] = (uint8_t)(reg[r1] + reg[r2]);
        } else if (opcode == 2) {
            // SUB r1 r2: A[r1] = (A[r1] - A[r2]) % 256
            int r1, r2;
            scanf("%d %d", &r1, &r2);
            reg[r1] = (uint8_t)(reg[r1] - reg[r2]);
        } else if (opcode == 3) {
            // MOV r num: A[r] = num (ограничено 8 битами)
            int r, num;
            scanf("%d %d", &r, &num);
            reg[r] = (uint8_t)num;
        } else if (opcode == 4) {
            // IR: Вывод значений регистров A, B, C, D
            printf("%d %d %d %d\n", reg[5], reg[6], reg[7], reg[8]);
        }
    }

    return 0;
}
```

Прежде всего сделаем ***комментарий об арифметических операциях по модулю 256***.

В языке C арифметика для типа `uint8_t` (беззнакового 8-битного целого числа) всегда выполняется по модулю 256. Это следует из того, что `uint8_t` хранит только *младшие* 8 бит результата, то есть:

- если результат умещается в 8 бит (значения `0–255`), он остается неизменным;
- если результат выходит за пределы 255 бит, старшие биты **отбрасываются**, остаются только младшие 8 бит.

Иными словами, **приведение к типу `uint8_t`** «обрезывает» число до 8 *младших* бит (отбрасывает переполнение), что **эквивалентно взятию остатка от деления на 256**. Следовательно, выражения: `reg[r1] = (uint8_t)(reg[r1] + reg[r2]);` и `reg[r1] = (reg[r1] + reg[r2]) % 256;` эквивалентны. В первом случае усечение происходит *автоматически* при приведении к `uint8_t`, во втором — *явно* через `% 256`.

Можно доказать это *экспериментально*:

```C
#include <stdio.h>  
#include <stdint.h>

int main() {  
    uint8_t a = 200, b = 100;

    printf("Приведение к uint8_t: %d\n", (uint8_t)(a + b));  
    printf("Явное %% 256: %d\n", (a + b) % 256);

    return 0;  
}
```

Вывод:

```C
Приведение к uint8_t: 44
Явное % 256: 44
```

Покажем это *в двоичной арифметике*.

Хотя `a` и `b` хранятся в 8 битах, их сумма вычисляется в 32 битах (чтобы не потерять вычисленное значение). Когда результат `a + b` приводится к `uint8_t`, остаются только младшие 8 бит, а старшие битовые разряды отбрасываются:

`200 =  11001000₂` (+)
`100 =  01100100₂` (=)
`300 = 100101100₂` .

Тип `uint8_t` хранит только младшие 8 бит — старшая единица (девятый бит) отбрасывается. Получаем: `00101100₂` = 44. Следовательно: `(uint8_t)(200 + 100) == 300 % 256 == 44`, что согласуется с экспериментом. Следовательно: `(uint8_t)(a + b) == (a + b) % 256`, что и предложено в основном цикле программы.

Теперь рассмотрим ***ключевые элементы программы*** и ее логику.

Программа построена на принципе *последовательного* чтения и выполнения инструкций, аналогичном работе большинства реальных вычислительных машин. Каждая инструкция однозначно определена и документирована, что делает эмулятор понятным и позволяет расширять его, например, для реализации архитектуры PDP-11.

**1\. Инициализация памяти**. В начале программы создается массив `reg[256]` типа `uint8_t`, который имитирует память машины. Каждый элемент массива представляет собой 1 байт памяти (значение от 0 до 255), причем *изначально все байты* *инициализированы нулями*. Регистры `A`, `B`, `C` и `D` размещены по адресам `5`, `6`, `7` и `8` соответственно.

**2\. Основной цикл обработки байт-кода**. В цикле программа выполняет инструкции, последовательно считывая коды операций (*opcodes*).

- Сначала `scanf("%d", &opcode)` считывает код операции.
- Если ввод прерван или содержит неверные данные (например, введено нечисловое значение), программа завершает выполнение.
- Каждая операция проверяется через цепочку `if...else`.

**3\. Обработка кодов операций.**

- `HLT` — *остановка*. При считывании `0` программа завершает выполнение.

- `ADD` — *сложение*. При считывании `1` выполняется сложение двух регистров:
  
  - считываются два операнда `r1` и `r2` — адреса регистров;
  - к значению `reg[r1]` прибавляется `reg[r2]`, результат записывается в `reg[r1]`;
  - поскольку `reg[]` имеет тип `uint8_t`, результат вычисляется по модулю 256 — если сумма превышает 255, происходит переполнение и *отсчет продолжается с 0*.

- `SUB` — *вычитание*. При считывании `2` выполняется вычитание:
  
  - из значения регистра `r1` вычитается значение регистра `r2`;
  - результат записывается в `reg[r1]`;
  - поскольку регистры — `uint8_t`, операция выполняется по модулю 256 (например, `5 - 10 = 251`, поскольку `-5 mod 256 = 251`).

- `MOV` — *присваивание*. При считывании `3` программа записывает число в регистр:
  
  - из первого операнда считывается адрес регистра `r`;
  - из второго операнда считывается числовое значение, которое записывается в `reg[r]`, указанный в первом операнде;
  - число автоматически приводится к `uint8_t`, что ограничивает его значением `0–255`.

- `IR` — *вывод*. При считывании `4` программа выводит текущие значения регистров `A`, `B`, `C` и `D`, размещенных по адресам `5`, `6`, `7` и `8` соответственно: `printf("%d %d %d %d\n", reg[5], reg[6], reg[7], reg[8]);`. 

*Оценка*. Использование `if...else`, несмотря на свою простоту и читаемость, имеет *недостатки*. Во-первых, такая программа проверяет *все* условия подряд, и при увеличении числа команд выполнение будет замедляться. Во-вторых, добавление новых операций вероятно потребует изменения структуры условий, а это наверняка приведет к необходимости переписать программу, усложнит ее, сделает менее читаемой и увеличит риск возникновения ошибок.

### Решение **с использованием `switch` и обработка ошибок ввода**

```C
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>

int main() {
    /* Инициализация памяти: 256 ячеек по 8 бит */
    // Регистры A, B, C, D находятся по адресам 5, 6, 7, 8
    uint8_t reg[256] = {0};
    int opcode;

    while (1) {
        if (scanf("%d", &opcode) != 1) {
            fprintf(stderr, "Ошибка ввода кода операции.\n");
            exit(EXIT_FAILURE);
        }

        switch (opcode) {
            case 0: // HLT: Завершить выполнение программы
                return 0;

            case 1: { // ADD: сложение регистров
                int r1, r2;
                if (scanf("%d %d", &r1, &r2) != 2) {
                    fprintf(stderr, "Ошибка ввода операндов операции ADD.\n");
                    exit(EXIT_FAILURE);
                }
                reg[r1] = (uint8_t)(reg[r1] + reg[r2]);
                break;
            }

            case 2: { // SUB: вычитание
                int r1, r2;
                if (scanf("%d %d", &r1, &r2) != 2) {
                    fprintf(stderr, "Ошибка ввода операндов операции SUB.\n");
                    exit(EXIT_FAILURE);
                }
                reg[r1] = (uint8_t)(reg[r1] - reg[r2]);
                break;
            }

            case 3: { // MOV: запись числа в регистр
                int r, num;
                if (scanf("%d %d", &r, &num) != 2) {
                    fprintf(stderr, "Ошибка ввода операндов операции MOV.\n");
                    exit(EXIT_FAILURE);
                }
                reg[r] = (uint8_t)num;
                break;
            }

            case 4: // IR: вывод содержимого регистров
                printf("%d %d %d %d\n", reg[5], reg[6], reg[7], reg[8]);
                break;

            default:
                fprintf(stderr, "Неизвестный код операции: %d\n", opcode);
                exit(EXIT_FAILURE);
        }
    }

    return 0;
}
```

Рассмотрим ***некоторые элементы программы*** и ее логику.

**1\. Обработка ошибок ввода**. Если `scanf()` не удается считать корректные данные (например, из-за некорректного формата ввода), программа завершает выполнение с сообщением об ошибке.

**2\. Использование оператора `switch`**.

- `case 0` — *HLT*. Немедленное завершение программы.
- `case 1` — *ADD*. Сложение значений двух регистров.
- `case 2` — *SUB*. Вычитание значения одного регистра из другого.
- `case 3` — *MOV*. Запись указанного числа в регистр.
- `case 4` — *IR*. Вывод текущих значений регистров.
- `default`. Обработчик неизвестных команд, предотвращающий выполнение некорректного кода. 

*Оценка*. Перейдя к использованию `switch`, мы не только улучшили читаемость кода, но и упростили дальнейшее расширение эмулятора. Вместо того чтобы каждый раз менять серию условий `if...else`, добавление нового кода операции теперь сводится к простому добавлению нового случая в блок `switch`. Кроме того, в отличие от последовательностей `if...else`, оператор `switch` позволяет компилятору лучше оптимизировать код — обычно он преобразуется в таблицу переходов (*jump table*) или бинарный поиск, что делает его быстрее при большом числе вариантов.

### Решение с использованием массива указателей на функции `func_ptr[]`

Теперь рассмотрим *оптимизированное решение* с использованием массива указателей на функции (*таблица команд*), которое позволяет избавиться от потенциально длинных цепочек `if...else` или `switch` в основной функции программы, делает код более гибким и упрощает его масштабирование. Таблицу команд можно хранить и расширять в отдельном файле — отдельно от основной функции.

```C
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>

/* Инициализация памяти: 256 ячеек по 8 бит */
uint8_t reg[256] = {0};

/* Функции, соответствующие операциям */
void hlt() {
    exit(0);
}

void add() {
    int r1, r2;
    if (scanf("%d %d", &r1, &r2) != 2) {
        fprintf(stderr, "Ошибка ввода операндов операции ADD.\n");
        exit(EXIT_FAILURE);
    }
    reg[r1] = (uint8_t)(reg[r1] + reg[r2]);
}

void sub() {
    int r1, r2;
    if (scanf("%d %d", &r1, &r2) != 2) {
        fprintf(stderr, "Ошибка ввода операндов операции SUB.\n");
        exit(EXIT_FAILURE);
    }
    reg[r1] = (uint8_t)(reg[r1] - reg[r2]);
}

void mov() {
    int r, num;
    if (scanf("%d %d", &r, &num) != 2) {
        fprintf(stderr, "Ошибка ввода операндов операции MOV.\n");
        exit(EXIT_FAILURE);
    }
    reg[r] = (uint8_t)num;
}

void ir() {
    printf("%d %d %d %d\n", reg[5], reg[6], reg[7], reg[8]);
}

/* Массив указателей на функции */
void (*operations[5])() = {hlt, add, sub, mov, ir};

/* Основная функция программы */
int main() {
    int opcode;

    while (scanf("%d", &opcode) == 1) {
        if (opcode < 0 || opcode > 4) {
            fprintf(stderr, "Неизвестный код операции: %d\n", opcode);
            exit(EXIT_FAILURE);
        }
        operations[opcode](); // Вызов соответствующей функции
    }

    return 0;
}
```

Прежде всего сделаем ***комментарий об использовании массива указателей на функции `func_ptr[]`***.

В подзаголовке к этому разделу упоминается `func_ptr[]`, в коде мы используем запись `operations[]`. Поясним: `func_ptr[]` является общим обозначением метода, `operations[]` — конкретной реализацией в нашей программе. Массив `operations[]` содержит указатели на функции, каждая из которых описывает конкретную операцию. Доступ к нужной операции осуществляется через индекс массива, который равен значению кода операции.

Теперь рассмотрим ***некоторые элементы программы***.

**1\. Для каждой операции дается определение собственной функции**.

- `hlt()` — завершает выполнение программы (`exit(0);`).
- `add()` — выполняет сложение двух регистров.
- `sub()` — выполняет вычитание значений регистров.
- `mov()` — записывает число в регистр.
- `ir()` — выводит значения регистров `A`, `B`, `C` и `D`.

**2\. Создается массив `operations[5]` с указателями на функции**, которые ранее были определены согласно операциям: `void (*operations[5])() = {hlt, add, sub, mov, ir};`.

**3. Обработка ввода**.

- Считывается `opcode`, проверяется его корректность (`opcode < 0 || opcode > 4`).
- Если ввод корректный, вызывается соответствующая функция из `operations[opcode]`. 

*Оценка*. Использование массива указателей на функции сделало код более удобным для расширения. Каждая операция теперь вынесена в отдельную функцию, и для добавления новой операции достаточно внести пару строк в таблицу. Определения функций можно хранить в отдельном файле, что упрощает чтение и изменение основной функции, а также делает архитектуру программы более гибкой.

## Заключение

От чтения простейших мнемоник и интерпретации байт-кода мы перешли к написанию небольшой программы на языке С, чтобы понять логику создания эмулятора и интерпретатора машинных команд гипотетической вычислительной машины «Q». Мы последовательно совершенствовали интерпретатор, переходя от простых цепочек `if...else` к более структурированному `switch`, а затем к оптимальному решению с массивом указателей на функции `func_ptr[]`. Хотя столь небольшие программы не дают полного представления о наилучшем решении, предположение о масштабируемости (например, для эмуляции PDP-11 с большим числом команд) помогает лучше понять различия между методами. В следующих записях журнала разработки мы перейдем непосредственно к работе с PDP-11.
