## Сверхкраткое введение в практику

Дана **вычислительная машина** «Q» с четырьмя **регистрами** (ячейками), размером в **1 байт** каждый. Каждый регистр имеет **имя** и **адрес**, по которому к нему можно обратиться:

| Имя | Адрес |
| --- | --- |
| A   | 5   |
| B   | 6   |
| C   | 7   |
| D   | 8   |

Программист использует **мнемоники** — символьные обозначения машинных операций (инструкций), для него *программа* имеет вид текста мнемоник с аргументами. Для машины *операции* представлены **кодами** (*opcodes*) в виде целых чисел:

| Код | Мнемоника | Аргумент | Операция (инструкция) |
| --- | --- | --- | --- |
| 0   | HLT | —   | Завершить программу |
| 1   | ADD | reg1 reg2 | Сложить значения, хранящиеся в регистрах *reg1* и *reg2*, результат сложения записать в *reg1* (*reg2* оставить без изменения) |
| 2   | SUB | reg1 reg2 | Вычесть значение *reg2* из значения *reg1*, результат вычитания записать в *reg1* (*reg2* оставить без изменения) |
| 3   | MOV | reg number | Записать значение (*number*) в указанный регистр *reg* |
| 4   | IR  | —   | Вывести на экран значения всех регистров по порядку через пробел |

Дана **программа в виде кодов** (целых чисел) для выполнения компьютером, которую будем называть **байт-кодом** (поскольку длина каждого опкода составляет один байт):

```C
3 5 1
3 6 2
1 5 6
4
0
```

**В выводе** на печать получаем:

```C
3 2 0 0
```

Почему `3200`?

### ***Чтение***

*Читаем* слева направо по строкам. Первая последовательность чисел — 3, 5 и 1, что значит: «Код 3 означает операцию (инструкцию) `MOV`»; «число 5 означает первый аргумент операции `MOV`, а именно номер адреса 5, который носит имя регистра A»; «число 1 означает второй аргумент операции `MOV`, а именно целое число 1». Иными словами, первое число означает инструкцию (операцию), два других составляют ее аргументы. У инструкции `MOV` (код операции 3) два аргумента — адрес регистра и числовое значение, которое будет записано в этот регистр. И так далее:

| Код | Мнемоника | Действие согласно инструкции | Содержимое регистров A B C D в результате выполнения операции |
| --- | --- | --- | --- |
| 3 5 1 | MOV A 1 | Записать в регистр А число 1 | 1 0 0 0 |
| 3 6 2 | MOV B 2 | Записать в регистр B число 2 | 1 2 0 0 |
| 1 5 6 | ADD A B | Сложить значения, хранящиеся в регистрах A и B, результат записать в A, оставить без изменений B | 3 2 0 0 |
| 4   | IR  | Вывести на печать содержимое всех регистров | 3 2 0 0 |
| 0   | HLT | Завершить программу | 3 2 0 0 |

Рассмотрим **еще один пример**.  
Дана программа в виде кодов:

```C
3 6 7
3 7 1
2 6 7
4
0
```

При выводе получаем:

```C
0 6 1 0
```

*Читаем*:

| Код | Мнемоника | Действие согласно инструкции | Содержимое регистров A B C D в результате выполнения операции |
| --- | --- | --- | --- |
| 3 6 7 | MOV B 7 | Записать в регистр B число 7 | 0 7 0 0 |
| 3 7 1 | MOV C 1 | Записать в регистр C число 1 | 0 7 1 0 |
| 2 6 7 | SUB B C | Вычесть из значения регистра B — значение регистра С, результат записать в B, оставить без изменений C | 0 6 1 0 |
| 4   | IR  | Вывести на печать содержимое всех регистров | 0 6 1 0 |
| 0   | HLT | Завершить программу | 0 6 1 0 |

### ***Письмо***

Теперь *напишем программу на языке C*, где роль регистров вычислительной машины «Q» будут выполнять **переменные**. Будем читать байт-коды, интерпретировать их, изменять значения переменных (регистров) и выводить на экран их содержимое.

Дана программа в виде кодов:

```C
3 5 1  
3 6 2  
1 5 6  
4  
0
```

При выводе получаем:

```C
3 2 0 0
```

При выводе на экран в первых двух регистрах (A и B) отображаются значения 3 и 2, регистры C и D содержат нули.

Сперва приведем **два работающих решения**, затем разберем и прокомментируем каждое из них. Данные для тестирования см. в: `test/1.2.test.md`.

### **Решение с использованием `if...else`**

```C
#include <stdio.h>
#include <stdint.h>

int main() {
    /* Инициализация памяти вычислительной машины "Q": 256 ячеек по 8 бит */
    // Регистры A, B, C, D располагаются по адресам 5, 6, 7 и 8 соответственно
    uint8_t reg[256] = {0};
    int opcode;

    /* Основной цикл обработки байт-кода */
    // Считываем опкод и выполняем соответствующую инструкцию
    while (scanf("%d", &opcode) == 1) {
        if (opcode == 0) {
            // HLT: Завершить выполнение программы
            break;
        } else if (opcode == 1) {
            // ADD: Сложить значения регистров
            // Считываем адреса регистров: r1 (куда записывать сумму) и r2 (откуда брать второе слагаемое)
            int r1, r2;
            scanf("%d %d", &r1, &r2);
            // Выполняем сложение по модулю 256
            reg[r1] = (uint8_t)(reg[r1] + reg[r2]);
        } else if (opcode == 2) {
            // SUB: Вычесть значение второго регистра из первого
            int r1, r2;
            scanf("%d %d", &r1, &r2);
            // Выполняем вычитание с учетом арифметики по модулю 256
            reg[r1] = (uint8_t)(reg[r1] - reg[r2]);
        } else if (opcode == 3) {
            // MOV: Записать число в указанный регистр
            // Считываем адрес регистра и число для записи
            int r, num;
            scanf("%d %d", &r, &num);
            reg[r] = (uint8_t)num;
        } else if (opcode == 4) {
            // IR: Вывести содержимое регистров A, B, C, D
            // Регистр A — адрес 5; B — 6; C — 7, D — 8
            printf("%d %d %d %d\n", reg[5], reg[6], reg[7], reg[8]);
        }
    }

    return 0;
}
```

Рассмотрим некоторые ключевые элементы программы и ее логику.

Логика программы основана на принципе *последовательного* чтения и выполнения инструкций, иначе говоря, на архитектуре реальных вычислительных машин. Каждая инструкция однозначно определена и документирована, что облегчает как первоначальное понимание работы эмулятора (сверхкраткое введение в практику), так и его дальнейшее расширение (переход к архитектуре PDP-11).

**Инициализация памяти**. Сперва создадим массив `reg[256]` беззнакового типа `uint8_t`, который будет имитировать память машины. Каждый элемент массива — один байт памяти (значение от 0 до 255), *все элементы массива изначально инициализированы нулями*. Регистры A, B, C и D находятся в ячейках с адресами 5, 6, 7 и 8 соответственно.

**Основной цикл обработки байт-кода**. В цикле программа считывает код операции (*opcode*) с помощью функции `scanf("%d", &opcode)`. Если ввод прерван или неверен (например, введено нецелое число), программа завершает работу. В цикле происходит последовательная обработка байт-кода с помощью цепочки условий `if...else`.

**Обработка кодов операций:**

- **Opcode 0 (HLT)**. При считывании 0 программа завершает выполнение, что соответствует инструкции остановки.
- **Opcode 1 (ADD)**. При считывании 1 программа выполняет операцию сложения. Сначала считываются два регистра (`r1`, `r2`). Значение регистра `r2` прибавляется к значению регистра `r1`, результат записывается в регистр `r1`. Так как используется тип `uint8_t`, операция сложения выполняется по модулю 256 (то есть, если результат сложения превышает 255, происходит «переполнение» и счет начинается с 0).
- **Opcode 2 (SUB)**. При считывании 2 выполняется операция вычитания. Из значения регистра `r1` вычитается значение регистра `r2`, результат сохраняется в регистр `r1`. Операция также выполняется по модулю 256.
- **Opcode 3 (MOV)**. При считывании 3 программа записывает значение в регистр. Сначала из первого аргумента считывается адрес регистра `r`, затем из второго аргумента считывается числовое значение, которое будет записано в указанный регистр. Это действие аналогично простой операции присваивания.
- **Opcode 4 (IR)**. При считывании 4 программа выводит на экран текущие значения всех четырех регистров (A, B, C, D), находящихся по адресам 5, 6, 7 и 8.

Использование цепочки `if...else`, несмотря на свою простоту, может иметь один существенный *недостаток* при разработке эмулятора PDP-11. Когда количество опкодов и операций возрастет — а это неизбежно случится, — количество проверок в цепочке `if...else` также возрастет, и тогда программа окажется куда менее простой и плохо читаемой. Кроме того, при добавлении новых операций, вероятно, придется изменять саму структуру условий, что почти наверняка приведет к необходимости модификации существующего кода и будет препятствовать легкому расширению программы. Следовало бы счесть это за недостаток.

### Решение **с использованием `switch` (и с обработкой ошибок ввода)**:

```C
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>

int main() {
    /* Инициализация памяти: 256 ячеек по 8 бит */
    // Регистры A, B, C, D находятся по адресам 5, 6, 7, 8
    uint8_t reg[256] = {0};
    int opcode;

    while (1) {
        if (scanf("%d", &opcode) != 1) {
            fprintf(stderr, "Ошибка ввода кода операции.\n");
            exit(EXIT_FAILURE);
        }

        switch (opcode) {
            case 0: // HLT: Завершить выполнение программы
                return 0;

            case 1: { // ADD: сложение регистров
                int r1, r2;
                if (scanf("%d %d", &r1, &r2) != 2) {
                    fprintf(stderr, "Ошибка ввода аргументов ADD.\n");
                    exit(EXIT_FAILURE);
                }
                reg[r1] = (uint8_t)(reg[r1] + reg[r2]);
                break;
            }

            case 2: { // SUB: вычитание
                int r1, r2;
                if (scanf("%d %d", &r1, &r2) != 2) {
                    fprintf(stderr, "Ошибка ввода аргументов SUB.\n");
                    exit(EXIT_FAILURE);
                }
                reg[r1] = (uint8_t)(reg[r1] - reg[r2]);
                break;
            }

            case 3: { // MOV: запись числа в регистр
                int r, num;
                if (scanf("%d %d", &r, &num) != 2) {
                    fprintf(stderr, "Ошибка ввода аргументов MOV.\n");
                    exit(EXIT_FAILURE);
                }
                reg[r] = (uint8_t)num;
                break;
            }

            case 4: // IR: вывод содержимого регистров
                printf("%d %d %d %d\n", reg[5], reg[6], reg[7], reg[8]);
                break;

            default:
                fprintf(stderr, "Неизвестный код операции: %d\n", opcode);
                exit(EXIT_FAILURE);
        }
    }

    return 0;
}
```

Рассмотрим некоторые ключевые элементы программы и ее логику.

#### Организация памяти:

- **Массив `reg[256]`**. Выделяем 256 байт, которые представляют всю доступную память (эмулятора). *Изначально все ячейки заполнены нулями*.
- **Регистры**. Из этого массива используем конкретные ячейки для имитации регистров. Это позволит сохранить простоту модели и вместе с тем показать принцип адресации: *вместо именованных переменных использовать адреса в памяти*.

#### Основной цикл обработки инструкций:

- **Цикл чтения**. Программа работает в бесконечном цикле `while (1)`, на каждой итерации считывается число и интерпретируется как *opcode*.
    
- **Обработка ошибок ввода**. Если `scanf` корректно не считывает число (например, при преждевременном окончании ввода или некорректном формате), выводится сообщение об ошибке, и программа завершает работу с кодом ошибки.
    

#### Использование оператора *switch*:

- **`case 0` (HLT)**. При считывании 0 программа немедленно завершается, что соответствует инструкции остановки.
    
- **`case 1` (ADD)**. После кода операции считываются два числа (`r1` и `r2)`, означающие адреса регистров (*reg1 reg2*), затем складываются значения этих регистров, результат сложения записывается в регистр по адресу `r1`. Сложение происходит по модулю 256, поскольку используется беззнаковый тип `uint8_t`. Это значит, что если сумма превысит 255, произойдет «переполнение», значение «провернется»: например, 250 + 10 даст 4.
    
- **`case 2` (SUB)**. После кода операции считываются два адреса, из значения регистра по адресу `r1` вычитается значение регистра по адресу `r2`, результат сохраняется в `r1`. Если результат отрицательный, он корректно интерпретируется по модулю 256, благодаря использованию типа `uint8_t`.
    
- **`case 3` (MOV)**. После кода операции, считываются два числа — `r` (адрес регистра) и `num` (числовое значение). В ячейку `reg[r]` записывается значение `num`. Это простая операция записи, аналогичная присваиванию переменной нового значения.
    
- **`case 4` (IR)**. Инструкция вывода состояния регистров: на экран выводятся значения ячеек с адресами 5, 6, 7 и 8. Это позволяет увидеть текущие значения регистров после выполнения ряда операций.
    
- **`default`**. Если *opcode* не соответствует ни одному из известных вариантов, выводится сообщение об ошибке (что позволяет перейти к поиску ошибок в самом байт-коде).
    

Перейдя к использованию `switch`, мы не только улучшили читаемость кода, но и упростили дальнейшие расширения эмулятора. Вместо того чтобы каждый раз менять серию условий `if...else`, добавление нового опкода теперь сводится к простому добавлению нового случая в `switch`.
